---
title: "Abundance Analysis"
author: "Lauren Liu"
date: "8/6/2018"
output: html_document
---
# Analysis of abundances.

```{r}
library(dplyr)
library(ggplot2)
library(reshape2)
library(moments)
```

```{r}
abundance_mode <- "transcript"
join_by <- paste0(abundance_mode, "_id")
```

```{r}
#base_path <- "/home/leliu/reads/human/sims/"
base_path <- "/home/leliu/reads/human/"

#methods <- c("kallisto", "Salmon", "RapMap")
methods <- c("kallisto", "Salmon_0.8.2", "Salmon", "HISAT2", "STAR", "quant")#, "diff.1", "diff.1.inc", "diff.2", "diff.3", "diff.4")
#methods <- c("quant", "quant.original")

#datasets <- c(1:10)
datasets <- c("SRR3191542")#, "SRR3191543", "SRR3191544", "SRR3191545")
#datasets <- c("SRR4045931")
```

## Reading in tables.
### Loading files.

Read in the gene-transcript mapping so that we can perform gene counts if we so desire.

```{r}
gene_table <- read.table("~/human/Homo_sapiens.GRCh38.92.chr.transcripts", sep='\t', header = FALSE, stringsAsFactors = FALSE)
names(gene_table) <- c("gene_id", "transcript_id")
head(gene_table)
tail(gene_table)

get_gene_abundances <- function(table, counts_column) {
    temp <- sym(counts_column)
    inner_join(table, gene_table, by="transcript_id") %>% group_by(gene_id) %>% summarise(!! counts_column := sum(!! temp))
}
```

```{r}
read_counts <- function(path) {
    table <- read.table(path, header = TRUE, stringsAsFactors = FALSE)
    # Get rid of all the columns we don't need.
    table$length <- NULL
    table$eff_length <- NULL
    table$tpm <- NULL
    table$gene_id <- NULL
    table$length <- NULL
    table$effective_length <- NULL
    table$TPM <- NULL
    table$FPKM <- NULL
    table$IsoPct <- NULL
    if ("est_counts" %in% names(table)) {
        table$count <- table$est_counts
        table$est_counts <- NULL
    }
    #table <- table[table$count!=0,]
    if ("target_id" %in% names(table)) {
        table$transcript_id <- table$target_id
        table$target_id <- NULL
    }
    if (abundance_mode == "gene") {
        table <- get_gene_abundances(table, "count")
    }
    table
}
```

```{r}
abundances <- lapply(datasets, function(d) lapply(methods, function(m) read_counts(paste0(base_path, d, "/", m, "/abundance_",  m,".tsv"))))
#abundances <- lapply(datasets, function(d) lapply(methods, function(m) read_counts(paste0(base_path, "abundance_",  d, ".", m,".tsv"))))

methods <- c("kallisto", "Salmon_0.8.2", "Salmon_0.11.2", "HISAT2", "STAR", "quant")

abundances <- lapply(abundances, function(d) lapply(c(1:length(methods)), function(i) { names(d[[i]])[names(d[[i]]) == "count"] <- methods[[i]]; d[[i]] }))

head(abundances[[1]][[1]])
tail(abundances[[1]][[1]])
```

Run only for simulations.

```{r}
true_abundances <- lapply(datasets, function(x)  read_counts(paste0("/home/lynnyi/dirichlet/6.3_sims_exp/rsem_perturb/", x, ".results.sim.isoforms.results")))

head(true_abundances[[1]])
tail(true_abundances[[1]])
```

Convert transcript abundances to gene abundances.

```{r eval = FALSE}
abundance_mode <- "gene"
join_by <- paste0(abundance_mode, "_id")

transcript_abundances <- abundances
true_transcript_abundances <- true_abundances

abundances <- lapply(abundances, function(d) lapply(c(1:length(methods)), function(i) get_gene_abundances(d[[i]], methods[[i]])))
true_abundances <- lapply(true_abundances, function(t) get_gene_abundances(t, "count"))
```

Convert back.

```{r eval = FALSE}
abundance_mode <- "transcript"
join_by <- paste0(abundance_mode, "_id")

gene_abundances <- abundances
true_gene_abundances <- true_abundances

abundances <- transcript_abundances
true_abundances <- true_transcript_abundances

rm(transcript_abundances, true_transcript_abundances)
```

# Analysis for Zika datasets.

## Correlations between all methods
Don't use this for things obtained from different transcriptomes or quantification algorithms--there's no guarantee that the intersection of transcripts every pair contains the same set of transcripts as the intersection of every other one.

```{r eval = FALSE}
get_cor <- function(table, type) {
    table <- Reduce(function(x, y) inner_join(x, y, by = join_by), table)
    Reduce(rbind, combn(methods, 2, function(m) data.frame(Method1 = m[[1]], Method2 = m[[2]], Correlation = cor(log2(table %>% select(m[[1]]) + 1), log2(table %>% select(m[[2]]) + 1), method=type)[[1]]), simplify=FALSE))
}
```

```{r eval = FALSE}
correlations_pearson <- lapply(abundances, function(d) get_cor(d, "pearson"))
correlations_spearman <- lapply(abundances, function(d) get_cor(d, "spearman"))
```

Mean and SD across datasets.

```{r eval = FALSE}
get_cor_stats <- function(tables) {
    tables <- Reduce(function(x, y) inner_join(x, y, by=c("Method1", "Method2")), tables)
    means <- rowMeans(tables[!colnames(tables) %in% c("Method1", "Method2")])
    sds <- lapply(c(1:nrow(tables)), function(i) sd(tables[i, !colnames(tables) %in% c("Method1", "Method2")])) %>% unlist
    tables <- data.frame(Method1=tables$Method1, Method2=tables$Method2, Mean=means, StDev=sds)
    tables
}
```

```{r eval = FALSE}
correlations_pearson <- get_cor_stats(correlations_pearson)
correlations_spearman <- get_cor_stats(correlations_spearman)
```

```{r eval = FALSE}
correlations_pearson$Mean <- round(correlations_pearson$Mean, 3)
correlations_pearson$StDev <- round(correlations_pearson$StDev, 3)
correlations_spearman$Mean <- round(correlations_spearman$Mean, 3)
correlations_spearman$StDev <- round(correlations_spearman$StDev, 3)
```

```{r eval = FALSE}
correlations_pearson
correlations_spearman
```

# Analysis for simulations.

### Merge matrices of the three methods + truth for each dataset.
It doesn't hurt, and it allows us to overlay the plots if we so desire.

```{r}
merged_abundances <- mapply(function(a, t) list(Reduce(function(x, y) inner_join(x, y, by=join_by), a, t)), abundances, true_abundances)
#merged_abundances <- lapply(merged_abundances, function(t) t[rowSums(t[,names(t) != join_by]) > 0,])

head(merged_abundances[[1]])
tail(merged_abundances[[1]])
```

### Bind matrices of the three methods together for each dataset.
Because I can't figure out how the heck to plot the things I want to using `merged_abundances`.

```{r}
rbound_abundances <- lapply(merged_abundances, function(t) melt(t, measure.vars=methods, variable.name="method", value.name="est_count"))
#rbound_abundances <- lapply(rbound_abundances, function(t) t[t$est_count != 0 | t$count != 0,])

head(rbound_abundances[[1]])
tail(rbound_abundances[[1]])
```

## Correlation.

```{r}
get_cor <- function(table, cor_method) {
    temp <- list()
    for (i in c(1:length(methods))) {
        temp <- append(temp, cor(log2(table$count + 1), log2(table[,i + 2] + 1), method=cor_method))
    }
    temp
}
correlations_pearson <- sapply(datasets, function(i) get_cor(merged_abundances[[i]], "pearson"))
correlations_spearman <- sapply(datasets, function(i) get_cor(merged_abundances[[i]], "spearman"))
rm(get_cor)

colnames(correlations_pearson) <- datasets
rownames(correlations_pearson) <- methods
colnames(correlations_spearman) <- datasets
rownames(correlations_spearman) <- methods
```

mean +/- SD

```{r}
get_cor_stats <- function(table) {
    table <- as.data.frame(t(table))
    table <- lapply(names(table), function(m) {
        temp <- table[,names(table) == m] %>% unlist
        temp <- data.frame(Mean = mean(temp), StDev = sd(temp), Method = m)
    })
    Reduce(rbind, table)
}
correlations_pearson <- get_cor_stats(correlations_pearson)
correlations_spearman <- get_cor_stats(correlations_spearman)
rm(get_cor_stats)
```

Round mean of mean and SD.

```{r}
correlations_pearson$Mean <- round(correlations_pearson$Mean, 4)
correlations_pearson$StDev <- round(correlations_pearson$StDev, 4)
correlations_spearman$Mean <- round(correlations_spearman$Mean, 4)
correlations_spearman$StDev <- round(correlations_spearman$StDev, 4)
```

Print.

```{r}
correlations_pearson
correlations_spearman
```

## Distances.
Calculating distance for rbound_abundances.

```{r}
rbound_abundances <- lapply(rbound_abundances, function(table) { table$dist <- table$est_count - table$count; table})

head(rbound_abundances[[1]])
tail(rbound_abundances[[1]])
```

### Various statistics about the distances.

```{r}
stats <- lapply(rbound_abundances, function(t) {
    temp <- Reduce(rbind, lapply(methods, function(m) {
        temp <- t$dist[t$method == m]
        data.frame(Mean = c(mean(temp)), StDev = c(sd(temp)), Skew = skewness(temp))
        }))
    temp$Method <- methods
    temp
})
stats <- lapply(c(1:length(datasets)), function(i) { stats[[i]]$Dataset <- datasets[[i]]
    stats[[i]]
})
stats <- Reduce(rbind, stats)
stats %>% group_by(Method) %>% summarise(AvgMean = mean(Mean), SDMean = sd(Mean), AvgSkew = mean(Skew), SDSkew = sd(Skew))
```

## Plotting with ggplot
Function `gg_color_hue` from StackOverflow [here](https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette).

```{r}
gg_color_hue <- function(n) {
    hues = seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
}

cols <- gg_color_hue(length(methods))

rm(gg_color_hue)
```

### Plotting MARDs

```{r}
MARDs <- lapply(rbound_abundances, function(d) d %>% filter(count != 0))
MARDs <- lapply(MARDs, function(d) { d$ARD <- abs(d$est_count - d$count) / d$count; d[is.na(d)] <- 0; d})
MARDs <- Reduce(rbind, lapply(MARDs, function(d) Reduce(rbind, lapply(methods, function(m) { data.frame(method = m, MARD = mean((d %>% filter(method == m))$ARD)) }))))

g <- ggplot(data=MARDs, aes(x=method, y=MARD, colour=method)) + geom_point() + guides(colour=FALSE) + ylab(paste0("MARD (expressed ", abundance_mode, "s)")) + xlab("Method") + ylim(0.1, 0.45) + theme(text = element_text(size=14), axis.text.x = element_text(angle=15, hjust=1))
ggsave(paste0("~/reads/human/images/sims.MARDs.", abundance_mode, ".tif"), device="tiff", dpi=350)
g

rm(MARDs)
```

### Plotting... MADs?

```{r}
MADs <- lapply(rbound_abundances, function(d) d %>% filter(count == 0))
MADs <- lapply(MADs, function(d) { d$AD <- abs(d$est_count - d$count); d})
MADs <- Reduce(rbind, lapply(MADs, function(d) Reduce(rbind, lapply(methods, function(m) { data.frame(method = m, MAD = mean((d %>% filter(method == m))$AD)) }))))

g <- ggplot(data=MADs, aes(x=method, y=MAD, colour=method)) + geom_point() + guides(colour=FALSE) + ylab(paste0("Mean distance (unexpressed ", abundance_mode, "s)")) + xlab("Method") + ylim(0, 1.4) + theme(text = element_text(size=14), axis.text.x = element_text(angle=15, hjust=1))
ggsave(paste0("~/reads/human/images/sims.MADs.", abundance_mode, ".tif"), device="tiff", dpi=350)
g

rm(MADs)
```

### Function to plot distances in distribution.

Scale each bar so by the total number of counts for that method.
Be careful using this function; it will fail if you set an xmin or xmax outside of the range of the distance.
Also this might be broken.

```{r eval = FALSE}
norm_dist_plot <- function(table) {
    xmin <- range(table$dist)[[1]]
    xmax <- 100
    bins <- 51
    not_shown <- sapply(methods, function(m) {
        length(which(table[table$method == m,]$dist < xmin)) + length(which(table[table$method == m,]$dist > xmax))})
  
    temp <- do.call("rbind", lapply(methods, function(m) data.frame(
        x=seq(from=xmin, to=xmax, by=(xmax - xmin) / (bins - 1)),
        ncount=c(unname(table(cut_interval(table$dist[table$method == m & table$dist > xmin & table$dist < xmax], n=bins)))),
        method=m)
    ))
    temp <- lapply(seq(length(methods)), function(j) { temp$ncount[temp$method == methods[[j]]] <- temp$ncount[temp$method == methods[[j]]] / nrow(table[table$method == methods[[j]],]); temp })
    g <- ggplot(temp, aes(x, ncount, fill=method)) + geom_col(position="dodge", width=(xmax - xmin) / (bins - 1))
    g <- g + xlab("Distance = method - true") + ylab("Frequency")
    g <- g + scale_fill_manual(name="Method", labels=c(paste0(methods, ": ", not_shown, " not shown")), values=cols)
    g <- g + theme(legend.position=c(.77, .77))
    g
}
```

### Actually using above function for everything.
By "everything", I actually mean only those entries for which truth == 0.

```{r eval = FALSE}
invisible(lapply(seq(length(datasets)), function(i) {
    norm_dist_plot(rbound_abundances[[i]] %>% filter(count == 0)) + labs(title = paste0("Distance distribution of false positives in simulation ", i, " (", abundance_mode, " counts)"))
    ggsave(paste0("~/reads/human/images/sims.", datasets[[i]], ".distance.", abundance_mode, ".tif"), device="tiff", dpi=350)
}))

norm_dist_plot(do.call("rbind", rbound_abundances) %>% filter(count == 0)) + labs(title=paste0("Distance distribution of false positives in all simulations (", abundance_mode, " counts)"))
ggsave(paste0("~/reads/human/images/sims.all.distance.", abundance_mode, ".tif"), device="tiff", dpi=350)
```
